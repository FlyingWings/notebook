并发控制
----
### 锁机制
- 读写锁
    - 读锁，也称共享锁，指锁定过程中别的客户端也可以读，不能写
    - 写锁，也称排他锁，锁定过程中其他用户不可写入，也不可能读取
- 锁粒度
    - 行级锁：并发处理用，只在存储引擎层面实现(即MySQL本身不支持)
        - 开销大，加锁慢，粒度小，会产生死锁
    - 表级锁：最基本的策略，直接锁表，其他用户操作不了该表
        - 开销小，加锁快，并发度低，不会死锁（整个表都锁了）
- InnoDB加锁方法：
    - 对于更新语句自动加排他锁
    - 对于一般SELECT语句，不加锁
    - 事务可以显式加锁
        - 共享锁：`SELECT * FROM xxx WHERE ... LOCK IN SHARE MODE`.
            - 用途：确保自己查的数据不让人修改，但是自己也不能修改（否则会触发别的用户的共享锁，导致死锁）
            - 只用于查最新数据，不修改
        - 排他锁：`SELECT * FROM xxx WHERE ... FOR UPDATE`.
            - 用途：保证自己的数据是最新数据，且只允许自己来修改
            - 要最新数据，且自己要修改
            
### 事务机制
- 定义：`一组`原子性的SQL查询，只有全部成功才成功，否则就统一失败
- 基本特性：
    - 原子性Atomic：原子操作，要么都成功要么都失败
    - 一致性Consistency：只要没提交，所做的更改都无效
    - 隔离性Isolation：事务之间不能互相影响
    - 持久性Durability：只要提交成功，就相对永久的保存
### 多版本并发控制MVCC
- 定义：通过某个机制生成不同时间点数据行的一致性快照，根据快照来提供一定级别的一致性读取
- 针对的是单个数据实体
- 类似git里不同的commit，对于用户来说就是同个数据有多个版本

### 隔离级别
- 定义：事务间隔离的级别，哪些操作是相互可见，哪些是不可见的
- 产生问题：
    - 根据不同隔离级别和业务场景会产生以下问题
        - 更新丢失：不同事务更新下同一行，则会覆盖前者的更改
        - 脏读：A事务在更新时，B读取了没有提交的行
        - 不可重复读：同一个事务对同一行数据两次读取结果不一致(由于该行数据过程中被改动了)
        - 幻读：同一个事务两次范围查询，数据行数不同(被其他事务插入或删除)
- 类型
    - 未提交-读：事务中的修改没提交，对其他事务也是可见的
        - 性能没有太大提升
        - 事务会读取没有提交的数据：即`脏读`(读取到了可能不存在的数据)
    - 提交-读：只有提交后事务的更改对其他事务才是可见的
        - 相对严格
        - 会导致不可重复读，因为别的事务在中间更改过指定的数据并提交了，所以两次读取后数据会不一致
    - 可重复-读：
        - 类似上者，提交后对其他事务可见，是MYSQL默认的级别
        - 同一事务的多个实例在并发读取数据时会看到同样的行(通过MVCC控制@TODO)
        - 可能导致的问题：幻读
        - InnoDB通过间隙锁解决这一问题(@TODO)
    - 可串行化
        - 最强，也最耗性能
        - 强制事务串行化执行，会导致大量的超时和锁竞争
        - 每一行数据都加读锁，保证读入内容一致（因为其他事务没法写)